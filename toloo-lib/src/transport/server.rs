/// Relay server: multi-endpoint accept loops (spec §9).
///
/// Implemented proto × skin combinations:
///   proto="ws",    skin=None              → plain WebSocket (JSON frames)
///   proto="wss",   skin=None              → WebSocket over TLS
///   proto="tcp",   skin=None              → plain TCP (4-byte BE length + JSON)
///   proto="tcp",   skin="x25519-v0.2"    → TCP with x25519-chacha20poly1305 AEAD
///   proto="http",  skin=None              → plain HTTP/1.1 POST handler
///   proto="https", skin=None              → HTTP/1.1 POST over TLS
///   proto="http",  skin="x25519-v0.2"    → HTTP/1.1 with per-request ECDH+AEAD body
///   proto="https", skin="x25519-v0.2"    → HTTP/1.1+TLS with per-request ECDH+AEAD body
///
/// `wss` and `https` require the endpoint's `tls` field to carry a pre-built
/// `TlsAcceptor` (with a self-signed cert generated by `transport::tls`).
///
/// Unimplemented proto/skin combos log a warning and skip that endpoint.
///
/// SQLite (`Pool`) is not `Sync`, so all connection tasks run on a single-threaded
/// `LocalSet` executor.
use std::net::SocketAddr;
use std::sync::atomic::{AtomicU64, AtomicUsize, Ordering};
use std::sync::Arc;

use anyhow::{Context, Result};
use futures_util::{SinkExt, StreamExt};
use serde_json::Value;
use tokio::io::{AsyncRead, AsyncReadExt, AsyncWrite, AsyncWriteExt};
use tokio::net::{TcpListener, TcpStream};
use tokio::task::{spawn_local, LocalSet};
use tokio_tungstenite::accept_async;
use tokio_tungstenite::tungstenite::Message;

use crate::pool::Pool;
use crate::requests::handlers::handle_request;
use crate::transport::framing::{FrameEncoder, FRAME_JSON};
use crate::transport::skin::SkinHandshake;
use toloo_core::types::{LocalNode, LocalRoom};
use toloo_core::{base64url, crypto};

// ══════════════════════════════════════════════════════════════════════
// Public types
// ══════════════════════════════════════════════════════════════════════

/// Live connection counters for a running relay instance.
pub struct RelayMetrics {
    pub active:    AtomicUsize,
    pub total:     AtomicUsize,
    pub bytes_in:  AtomicU64,
    pub bytes_out: AtomicU64,
}

impl RelayMetrics {
    pub fn new() -> Self {
        Self {
            active:    AtomicUsize::new(0),
            total:     AtomicUsize::new(0),
            bytes_in:  AtomicU64::new(0),
            bytes_out: AtomicU64::new(0),
        }
    }
}

impl Default for RelayMetrics {
    fn default() -> Self { Self::new() }
}

/// One transport endpoint that this relay should listen on.
pub struct EndpointConfig {
    /// Socket address to bind on (e.g. `0.0.0.0:17701`).
    pub addr:  SocketAddr,
    /// Transport protocol: `"ws"`, `"wss"`, `"tcp"`, `"http"`, `"https"`, …
    pub proto: String,
    /// Optional app-layer encryption skin (`"x25519-v0.2"` or `None`).
    pub skin:  Option<String>,
    /// URL path for HTTP/HTTPS endpoints (default `/`).
    pub path:  Option<String>,
    /// Pre-built TLS acceptor — required for `wss` and `https`, `None` otherwise.
    pub tls:   Option<Arc<tokio_rustls::TlsAcceptor>>,
}

/// Relay configuration passed to [`run_relay`].
pub struct RelayConfig {
    /// Relay's Ed25519 + X25519 identity.
    pub node:      LocalNode,
    /// Transport endpoints to listen on.  At least one required.
    pub endpoints: Vec<EndpointConfig>,
    /// Shared event pool.  Not `Sync`; all access happens on the local executor.
    pub pool:      Arc<Pool>,
    /// Rooms for which this relay holds the private key (key-holder rooms).
    pub rooms:     std::collections::HashMap<String, LocalRoom>,
    /// Optional live metrics counters.
    pub metrics:   Option<Arc<RelayMetrics>>,
}

// ══════════════════════════════════════════════════════════════════════
// Entry point
// ══════════════════════════════════════════════════════════════════════

/// Start the relay server inside a `LocalSet`.
///
/// Spawns one accept loop per endpoint.  Runs indefinitely until the outer
/// future is cancelled (e.g. via `tokio::select!` with a stop channel).
pub async fn run_relay(config: Arc<RelayConfig>) -> Result<()> {
    if config.endpoints.is_empty() {
        anyhow::bail!("RelayConfig has no endpoints");
    }

    let local = LocalSet::new();

    for ep in &config.endpoints {
        let cfg   = Arc::clone(&config);
        let addr  = ep.addr;
        let proto = ep.proto.clone();
        let skin  = ep.skin.clone();
        let path  = ep.path.clone().unwrap_or_else(|| "/".to_owned());
        let tls   = ep.tls.clone();

        local.spawn_local(async move {
            let result = match (proto.as_str(), skin.as_deref()) {
                // ── WebSocket ──────────────────────────────────────
                ("ws",  None) => run_ws_accept_loop(addr, None, cfg).await,
                ("wss", None) => match tls {
                    Some(t) => run_ws_accept_loop(addr, Some(t), cfg).await,
                    None    => Err(anyhow::anyhow!("wss endpoint missing TLS acceptor")),
                },
                // ── Raw TCP ────────────────────────────────────────
                ("tcp", None)                => run_tcp_plain_accept_loop(addr, cfg).await,
                ("tcp", Some("x25519-v0.2")) => run_tcp_x25519_accept_loop(addr, cfg).await,
                // ── HTTP / HTTPS ───────────────────────────────────
                ("http",  None)                => run_http_accept_loop(addr, path, None, None, cfg).await,
                ("http",  Some("x25519-v0.2")) => run_http_accept_loop(addr, path, None, Some("x25519-v0.2".to_owned()), cfg).await,
                ("https", None) => match tls {
                    Some(t) => run_http_accept_loop(addr, path, Some(t), None, cfg).await,
                    None    => Err(anyhow::anyhow!("https endpoint missing TLS acceptor")),
                },
                ("https", Some("x25519-v0.2")) => match tls {
                    Some(t) => run_http_accept_loop(addr, path, Some(t), Some("x25519-v0.2".to_owned()), cfg).await,
                    None    => Err(anyhow::anyhow!("https endpoint missing TLS acceptor")),
                },
                // ── Not yet implemented ───────────────────────────
                (p, s) => {
                    log_info(format!(
                        "endpoint proto={p} skin={s:?}: not yet implemented, skipping"
                    ));
                    Ok(())
                }
            };
            if let Err(e) = result {
                log_info(format!("endpoint {proto} error: {e}"));
            }
        });
    }

    local.run_until(futures_util::future::pending::<Result<()>>()).await
}

// ══════════════════════════════════════════════════════════════════════
// WebSocket — plain (ws) or over TLS (wss)
// ══════════════════════════════════════════════════════════════════════

async fn run_ws_accept_loop(
    addr:   SocketAddr,
    tls:    Option<Arc<tokio_rustls::TlsAcceptor>>,
    config: Arc<RelayConfig>,
) -> Result<()> {
    let listener = TcpListener::bind(addr).await
        .with_context(|| format!("failed to bind {} on {addr}", if tls.is_some() { "WSS" } else { "WS" }))?;
    log_info(format!("{} relay listening on {addr}", if tls.is_some() { "WSS" } else { "WS" }));

    loop {
        let (stream, peer_addr) = listener.accept().await.context("WS accept")?;
        let cfg = Arc::clone(&config);

        match &tls {
            None => {
                spawn_local(async move {
                    bump_metrics(&cfg, true);
                    if let Err(e) = do_ws_session(stream, &cfg).await {
                        log_info(format!("WS error from {peer_addr}: {e}"));
                    }
                    bump_metrics(&cfg, false);
                });
            }
            Some(tls_acc) => {
                let tls_acc = Arc::clone(tls_acc);
                spawn_local(async move {
                    match tls_acc.accept(stream).await {
                        Ok(tls_stream) => {
                            bump_metrics(&cfg, true);
                            if let Err(e) = do_ws_session(tls_stream, &cfg).await {
                                log_info(format!("WSS error from {peer_addr}: {e}"));
                            }
                            bump_metrics(&cfg, false);
                        }
                        Err(e) => log_info(format!("WSS TLS handshake error from {peer_addr}: {e}")),
                    }
                });
            }
        }
    }
}

/// Drive a WebSocket session over any `AsyncRead + AsyncWrite + Unpin` stream.
/// Used by both plain `ws` and TLS `wss`.
async fn do_ws_session<S>(stream: S, config: &RelayConfig) -> Result<()>
where
    S: AsyncRead + AsyncWrite + Unpin,
{
    let mut ws = accept_async(stream).await.context("WebSocket upgrade")?;
    while let Some(msg) = ws.next().await {
        let msg = msg.context("WebSocket read")?;
        match msg {
            Message::Text(text) => {
                if let Some(m) = &config.metrics {
                    m.bytes_in.fetch_add(text.len() as u64, Ordering::Relaxed);
                }
                let responses = dispatch_common(&text, config).await;
                for v in responses {
                    let out = v.to_string();
                    if let Some(m) = &config.metrics {
                        m.bytes_out.fetch_add(out.len() as u64, Ordering::Relaxed);
                    }
                    ws.send(Message::Text(out.into())).await.context("WS send")?;
                }
                // Signal end of response batch so clients can proceed.
                ws.send(Message::Text(r#"{"done":true}"#.into())).await.context("WS done")?;
            }
            Message::Binary(_) => {}
            Message::Close(_)  => break,
            Message::Ping(p)   => { ws.send(Message::Pong(p)).await.context("WS pong")?; }
            _ => {}
        }
    }
    Ok(())
}

// ══════════════════════════════════════════════════════════════════════
// TCP — plain framing (no skin): 4-byte BE length prefix + JSON payload
// ══════════════════════════════════════════════════════════════════════

async fn run_tcp_plain_accept_loop(addr: SocketAddr, config: Arc<RelayConfig>) -> Result<()> {
    let listener = TcpListener::bind(addr).await
        .with_context(|| format!("failed to bind plain TCP on {addr}"))?;
    log_info(format!("TCP plain relay listening on {addr}"));
    loop {
        let (stream, peer_addr) = listener.accept().await.context("TCP plain accept")?;
        let cfg = Arc::clone(&config);
        spawn_local(async move {
            bump_metrics(&cfg, true);
            if let Err(e) = do_tcp_plain_connection(stream, peer_addr, &cfg).await {
                log_info(format!("TCP plain error from {peer_addr}: {e}"));
            }
            bump_metrics(&cfg, false);
        });
    }
}

async fn do_tcp_plain_connection(
    mut stream: TcpStream,
    peer_addr:  SocketAddr,
    config:     &RelayConfig,
) -> Result<()> {
    log_info(format!("TCP plain connected: {peer_addr}"));
    loop {
        let mut len_buf = [0u8; 4];
        match stream.read_exact(&mut len_buf).await {
            Ok(_) => {}
            Err(e) if e.kind() == std::io::ErrorKind::UnexpectedEof => break,
            Err(e) => return Err(e.into()),
        }
        let len = u32::from_be_bytes(len_buf) as usize;
        if len > 1 << 20 { anyhow::bail!("frame too large: {len}"); }

        let mut payload = vec![0u8; len];
        stream.read_exact(&mut payload).await.context("TCP plain frame read")?;

        if let Some(m) = &config.metrics {
            m.bytes_in.fetch_add(4 + len as u64, Ordering::Relaxed);
        }

        let json_str = std::str::from_utf8(&payload).context("frame not valid UTF-8")?;
        let responses = dispatch_common(json_str, config).await;

        for v in responses {
            let s = v.to_string();
            let bytes = s.as_bytes();
            let prefix = (bytes.len() as u32).to_be_bytes();
            stream.write_all(&prefix).await.context("TCP plain length write")?;
            stream.write_all(bytes).await.context("TCP plain payload write")?;
            if let Some(m) = &config.metrics {
                m.bytes_out.fetch_add(4 + bytes.len() as u64, Ordering::Relaxed);
            }
        }
        stream.flush().await.context("TCP plain flush")?;
    }
    Ok(())
}

// ══════════════════════════════════════════════════════════════════════
// TCP — x25519-v0.2 skin (ephemeral ECDH + ChaCha20-Poly1305 AEAD)
// ══════════════════════════════════════════════════════════════════════

async fn run_tcp_x25519_accept_loop(addr: SocketAddr, config: Arc<RelayConfig>) -> Result<()> {
    let listener = TcpListener::bind(addr).await
        .with_context(|| format!("failed to bind TCP/x25519 on {addr}"))?;
    log_info(format!("TCP/x25519-v0.2 relay listening on {addr}"));
    loop {
        let (stream, peer_addr) = listener.accept().await.context("TCP x25519 accept")?;
        let cfg = Arc::clone(&config);
        spawn_local(async move {
            bump_metrics(&cfg, true);
            if let Err(e) = do_tcp_x25519_connection(stream, peer_addr, &cfg).await {
                log_info(format!("TCP/x25519 error from {peer_addr}: {e}"));
            }
            bump_metrics(&cfg, false);
        });
    }
}

async fn do_tcp_x25519_connection(
    mut stream: TcpStream,
    peer_addr:  SocketAddr,
    config:     &RelayConfig,
) -> Result<()> {
    let mut eph_pub_i = [0u8; 32];
    stream.read_exact(&mut eph_pub_i).await.context("failed to read eph_pub_i")?;

    let skin = SkinHandshake::new(
        config.node.sig.priv_key.clone(),
        config.node.sig.pub_key.clone(),
    );
    let mut handshake_out: Vec<Vec<u8>> = Vec::new();
    let (mut encoder, mut decoder) = skin.accept(&eph_pub_i, |b| handshake_out.push(b))?;

    for bytes in handshake_out {
        stream.write_all(&bytes).await.context("handshake write")?;
    }
    stream.flush().await.context("handshake flush")?;

    log_info(format!("TCP/x25519 handshake complete for {peer_addr}"));

    loop {
        let mut len_aead = [0u8; 18];
        match stream.read_exact(&mut len_aead).await {
            Ok(_) => {}
            Err(e) if e.kind() == std::io::ErrorKind::UnexpectedEof => break,
            Err(e) => return Err(e.into()),
        }

        let content_len = decoder
            .decode_content_len(&len_aead)
            .context("AEAD authentication failed (len)")?;

        let mut content_aead = vec![0u8; content_len + 16];
        stream.read_exact(&mut content_aead).await.context("frame content read")?;

        let mut wire = Vec::with_capacity(18 + content_len + 16);
        wire.extend_from_slice(&len_aead);
        wire.extend_from_slice(&content_aead);

        let (frame_type, frame_data) = decoder.decode(&wire).context("frame decode")?;
        if frame_type != FRAME_JSON { continue; }

        if let Some(m) = &config.metrics {
            m.bytes_in.fetch_add(wire.len() as u64, Ordering::Relaxed);
        }

        let json_str = std::str::from_utf8(&frame_data).context("frame not valid UTF-8")?;
        let response_frames = dispatch_tcp_x25519_frame(json_str, config, &mut encoder).await;
        for frame in response_frames {
            if let Some(m) = &config.metrics {
                m.bytes_out.fetch_add(frame.len() as u64, Ordering::Relaxed);
            }
            stream.write_all(&frame).await.context("response write")?;
        }
        stream.flush().await.context("response flush")?;
    }

    Ok(())
}

async fn dispatch_tcp_x25519_frame(
    json_str: &str,
    config:   &RelayConfig,
    encoder:  &mut FrameEncoder,
) -> Vec<Vec<u8>> {
    dispatch_common(json_str, config)
        .await
        .into_iter()
        .filter_map(|v| encoder.encode_json(&v.to_string()).ok())
        .collect()
}

// ══════════════════════════════════════════════════════════════════════
// HTTP / HTTPS — single request / response per connection (Connection: close)
// ══════════════════════════════════════════════════════════════════════
//
// Accepts POST <path> HTTP/1.1 with a JSON envelope body.
// Returns a JSON array of response envelopes.
// Plain HTTP uses a raw TcpStream; HTTPS wraps it with a TlsStream first.

async fn run_http_accept_loop(
    addr:   SocketAddr,
    path:   String,
    tls:    Option<Arc<tokio_rustls::TlsAcceptor>>,
    skin:   Option<String>,
    config: Arc<RelayConfig>,
) -> Result<()> {
    let proto = if tls.is_some() { "HTTPS" } else { "HTTP" };
    let listener = TcpListener::bind(addr).await
        .with_context(|| format!("failed to bind {proto} on {addr}"))?;
    log_info(format!("{proto} relay listening on {addr} (path={path} skin={skin:?})"));

    loop {
        let (stream, peer_addr) = listener.accept().await.context("HTTP(S) accept")?;
        let cfg   = Arc::clone(&config);
        let path  = path.clone();
        let skin  = skin.clone();

        match &tls {
            None => {
                spawn_local(async move {
                    if let Err(e) = do_http_connection(stream, peer_addr, &cfg, &path, skin.as_deref()).await {
                        log_info(format!("HTTP error from {peer_addr}: {e}"));
                    }
                });
            }
            Some(tls_acc) => {
                let tls_acc = Arc::clone(tls_acc);
                spawn_local(async move {
                    match tls_acc.accept(stream).await {
                        Ok(tls_stream) => {
                            if let Err(e) = do_http_connection(tls_stream, peer_addr, &cfg, &path, skin.as_deref()).await {
                                log_info(format!("HTTPS error from {peer_addr}: {e}"));
                            }
                        }
                        Err(e) => log_info(format!("HTTPS TLS error from {peer_addr}: {e}")),
                    }
                });
            }
        }
    }
}

/// Minimal HTTP/1.1 server handling a single POST request, then closing.
/// Works over any `AsyncRead + AsyncWrite + Unpin` (TcpStream or TlsStream).
async fn do_http_connection<S>(
    mut stream: S,
    _peer:      SocketAddr,
    config:     &RelayConfig,
    want_path:  &str,
    skin:       Option<&str>,
) -> Result<()>
where
    S: AsyncRead + AsyncWrite + Unpin,
{
    // Read headers byte-by-byte until the blank line (\r\n\r\n).
    let mut header_buf: Vec<u8> = Vec::with_capacity(2048);
    loop {
        let mut byte = [0u8; 1];
        match stream.read(&mut byte).await {
            Ok(0) => return Ok(()), // client closed before sending headers
            Ok(_) => header_buf.push(byte[0]),
            Err(e) => return Err(e.into()),
        }
        if header_buf.ends_with(b"\r\n\r\n") { break; }
        if header_buf.len() > 16 * 1024 {
            anyhow::bail!("HTTP headers exceed 16 KiB");
        }
    }

    // Parse request line + headers.
    let header_str = std::str::from_utf8(&header_buf).context("HTTP headers not UTF-8")?;
    let mut lines = header_str.split("\r\n");

    let req_line = lines.next().unwrap_or("");
    let mut parts = req_line.splitn(3, ' ');
    let method = parts.next().unwrap_or("");
    let path   = parts.next().unwrap_or("");

    let mut content_length: usize = 0;
    for line in lines {
        let ll = line.to_ascii_lowercase();
        if let Some(rest) = ll.strip_prefix("content-length:") {
            content_length = rest.trim().parse().unwrap_or(0);
        }
    }

    // Only handle POST to the configured path; everything else → 404.
    if method != "POST" || path != want_path {
        let body = b"Not Found\n";
        let resp = format!(
            "HTTP/1.1 404 Not Found\r\n\
             Content-Type: text/plain\r\n\
             Content-Length: {}\r\n\
             Connection: close\r\n\r\n",
            body.len()
        );
        stream.write_all(resp.as_bytes()).await.ok();
        stream.write_all(body).await.ok();
        stream.flush().await.ok();
        return Ok(());
    }

    // Read request body.
    if content_length > 1 << 20 {
        anyhow::bail!("HTTP request body too large: {content_length} bytes");
    }
    let mut body = vec![0u8; content_length];
    stream.read_exact(&mut body).await.context("HTTP body read")?;

    if let Some(m) = &config.metrics {
        bump_metrics(config, true);
        m.bytes_in.fetch_add(body.len() as u64, Ordering::Relaxed);
    }

    // Dispatch (with optional per-request ECDH skin).
    let resp_body = if skin == Some("x25519-v0.2") {
        dispatch_http_x25519(&body, config).await.context("HTTP x25519 dispatch")?
    } else {
        let json_str  = std::str::from_utf8(&body).context("request body not UTF-8")?;
        let responses = dispatch_common(json_str, config).await;
        serde_json::to_vec(&responses).context("response serialise")?
    };

    if let Some(m) = &config.metrics {
        m.bytes_out.fetch_add(resp_body.len() as u64, Ordering::Relaxed);
        m.active.fetch_sub(1, Ordering::Relaxed);
    }

    let resp_headers = format!(
        "HTTP/1.1 200 OK\r\n\
         Content-Type: application/json\r\n\
         Content-Length: {}\r\n\
         Connection: close\r\n\r\n",
        resp_body.len()
    );
    stream.write_all(resp_headers.as_bytes()).await.context("HTTP write headers")?;
    stream.write_all(&resp_body).await.context("HTTP write body")?;
    stream.flush().await.context("HTTP flush")?;

    Ok(())
}

// ══════════════════════════════════════════════════════════════════════
// Shared dispatch
// ══════════════════════════════════════════════════════════════════════

/// Per-request ECDH+AEAD dispatch for HTTP `x25519-v0.2` skin.
///
/// Request body:  `{"eph": BASE64URL_CLIENT_EPH_PUB, "enc": BASE64URL_CIPHERTEXT}`
/// Response body: `{"enc": BASE64URL_CIPHERTEXT}`
///
/// Key derivation (static-ephemeral ECDH):
///   shared     = X25519(relay_enc_priv, client_eph_pub)
///   salt       = SHA-256(client_eph_pub || relay_enc_pub)
///   req key+n  = HKDF-SHA256(shared, salt, "toloo-http-req-v0.2",  44)
///   resp key+n = HKDF-SHA256(shared, salt, "toloo-http-resp-v0.2", 44)
async fn dispatch_http_x25519(body: &[u8], config: &RelayConfig) -> Result<Vec<u8>> {
    let envelope: Value = serde_json::from_slice(body)
        .context("HTTP x25519: request body is not valid JSON")?;
    let eph_b64 = envelope["eph"].as_str()
        .ok_or_else(|| anyhow::anyhow!("HTTP x25519: missing 'eph' field"))?;
    let enc_b64 = envelope["enc"].as_str()
        .ok_or_else(|| anyhow::anyhow!("HTTP x25519: missing 'enc' field"))?;

    let eph_pub    = base64url::decode(eph_b64).context("HTTP x25519: decode eph")?;
    let ciphertext = base64url::decode(enc_b64).context("HTTP x25519: decode enc")?;

    let enc_priv_raw = base64url::decode(&config.node.enc.priv_key)
        .context("relay enc_priv decode")?;
    let enc_pub_raw  = base64url::decode(&config.node.enc.pub_key)
        .context("relay enc_pub decode")?;

    let shared = crypto::x25519_shared_secret(&enc_priv_raw, &eph_pub)
        .context("HTTP x25519: ECDH")?;

    let mut salt_data = Vec::with_capacity(eph_pub.len() + enc_pub_raw.len());
    salt_data.extend_from_slice(&eph_pub);
    salt_data.extend_from_slice(&enc_pub_raw);
    let salt = crypto::sha256(&salt_data);

    // Derive request key+nonce.
    let okm_req = crypto::hkdf_sha256(&shared, &salt, b"toloo-http-req-v0.2", 44);
    let mut key_req   = [0u8; 32];
    let mut nonce_req = [0u8; 12];
    key_req.copy_from_slice(&okm_req[0..32]);
    nonce_req.copy_from_slice(&okm_req[32..44]);

    let plaintext = crypto::chacha20_decrypt(&key_req, &nonce_req, &ciphertext)
        .context("HTTP x25519: request decrypt failed (wrong key or tampered)")?;

    let json_str  = std::str::from_utf8(&plaintext).context("decrypted body not UTF-8")?;
    let responses = dispatch_common(json_str, config).await;
    let resp_json = serde_json::to_vec(&responses).context("response serialise")?;

    // Derive response key+nonce.
    let okm_resp = crypto::hkdf_sha256(&shared, &salt, b"toloo-http-resp-v0.2", 44);
    let mut key_resp   = [0u8; 32];
    let mut nonce_resp = [0u8; 12];
    key_resp.copy_from_slice(&okm_resp[0..32]);
    nonce_resp.copy_from_slice(&okm_resp[32..44]);

    let encrypted = crypto::chacha20_encrypt(&key_resp, &nonce_resp, &resp_json);
    serde_json::to_vec(&serde_json::json!({ "enc": base64url::encode(&encrypted) }))
        .map_err(Into::into)
}

async fn dispatch_common(json_str: &str, config: &RelayConfig) -> Vec<Value> {
    let value: Value = match serde_json::from_str(json_str) {
        Ok(v)  => v,
        Err(e) => return vec![serde_json::json!({"error": "parse_error", "message": e.to_string()})],
    };
    match toloo_core::envelope::parse_envelope(value) {
        Ok(env) => match handle_request(env, &config.pool, config).await {
            Ok(responses) => responses,
            Err(e) => vec![serde_json::json!({"error": "internal", "message": e.to_string()})],
        },
        Err(e) => vec![serde_json::json!({"error": "invalid_envelope", "message": e.to_string()})],
    }
}

// ══════════════════════════════════════════════════════════════════════
// Helpers
// ══════════════════════════════════════════════════════════════════════

/// Increment or decrement active + (on connect) total metrics.
fn bump_metrics(config: &RelayConfig, connect: bool) {
    if let Some(m) = &config.metrics {
        if connect {
            m.active.fetch_add(1, Ordering::Relaxed);
            m.total.fetch_add(1, Ordering::Relaxed);
        } else {
            m.active.fetch_sub(1, Ordering::Relaxed);
        }
    }
}

fn log_info(msg: String) {
    eprintln!("[toloo] {msg}");
}
